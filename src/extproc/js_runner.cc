// Copyright 2010-2013 RethinkDB, all rights reserved.
#define __STDC_LIMIT_MACROS

//#include <stdint.h>
//#include <cmath>

//#include "errors.hpp"
//#include <boost/variant/get.hpp>
//#include <boost/make_shared.hpp>

//#include "containers/scoped.hpp"
//#include "extproc/extproc_job.hpp"
//#include "rdb_protocol/rdb_protocol_json.hpp"
//#include "containers/archive/boost_types.hpp"
//#include "rdb_protocol/js.hpp"
//#include "utils.hpp"
#include "extproc/js_runner.hpp"
#include "extproc/js_job.hpp"

const js_id_t MIN_ID = 1;
const js_id_t MAX_ID = UINT64_MAX;

js_scoped_id_t::js_scoped_id_t(js_runner_t *_parent, js_id_t _id) :
    parent(_parent), id(_id) { }

js_scoped_id_t::~js_scoped_id_t() {
    if (!empty()) reset();
}

bool js_scoped_id_t::empty() const {
    return id == INVALID_ID;
}

js_id_t js_scoped_id_t::get() const {
    return id;
}

js_id_t js_scoped_id_t::release() {
    js_id_t temp_id = id;
    id = INVALID_ID;
    return temp_id;
}

void js_scoped_id_t::reset(js_id_t _id) {
    guarantee(id != _id);
    if (!empty()) {
        parent->release(id);
    }
    id = _id;
}

// This class allows us to manage timeouts in a cleaner manner
class js_timeout_t {
public:
    // Construct a sentry on the stack when performing a timed js call, and it
    //  will run the timer for the duration it is in scope
    class sentry_t {
    public:
        sentry_t(js_timeout_t *_parent, uint64_t timeout_ms) :
            parent(_parent) {
            if (parent->timer.is_pulsed()) {
                throw interrupted_exc_t();
            }
            parent->timer.start(timeout_ms);
        }
        ~sentry_t() {
            if (!parent->timer.is_pulsed()) {
                parent->timer.cancel();
            }
        }
    private:
        js_timeout_t *parent;
    };

    signal_t *get_signal() {
        return &timer;
    }

private:
    signal_timer_t timer;
};

// Contains all the data relevant to a single worker process, so we can
//  easily clear it all and replace it
class js_runner_t::job_data_t {
public:
    job_data_t(extproc_pool_t *pool, signal_t *interruptor) :
        combined_interruptor(interruptor, js_timeout.get_signal()),
        js_job(pool, &combined_interruptor) { }

    explicit job_data_t(extproc_pool_t *pool) :
        js_job(pool, js_timeout.get_signal()) { }

    std::set<js_id_t> used_ids;
    js_timeout_t js_timeout;
    wait_any_t combined_interruptor;
    js_job_t js_job;
};

js_runner_t::js_runner_t() { }

js_runner_t::~js_runner_t() {
    if (job_data.has()) {
        // Have the worker job exit its loop - if anything fails,
        //  don't worry, the worker will be cleaned up
        try {
            job_data->js_job.exit();
        } catch (...) {
            // Do nothing
        }
    }
}

bool js_runner_t::connected() const {
    return job_data.has();
}

// Starts the javascript function in the worker process
void js_runner_t::begin(extproc_pool_t *pool, signal_t *interruptor) {
    if (interruptor == NULL) {
        job_data.init(new job_data_t(pool));
    } else {
        job_data.init(new job_data_t(pool, interruptor));
    }
}

void js_runner_t::release(js_id_t id) {
    if (job_data.has()) {
        std::set<js_id_t>::iterator it = job_data->used_ids.find(id);
        guarantee(it != job_data->used_ids.end());
        job_data->used_ids.erase(it);

        try {
            job_data->js_job.release(id);
        } catch (...) {
            job_data.reset();
            throw;
        }
    }
}

js_result_t js_runner_t::eval(const std::string &source,
                              const req_config_t &config) {
    guarantee(job_data.has());

    object_buffer_t<js_timeout_t::sentry_t> sentry;
    sentry.create(&job_data->js_timeout, config.timeout_ms);
    js_result_t result;

    try {
        result = job_data->js_job.eval(source);
    } catch (...) {
        // Sentry must be destroyed before the js_timeout
        sentry.reset();
        job_data.reset();
        throw;
    }

    // We need to "note" any function id generated by this eval
    js_id_t *any_id = boost::get<js_id_t>(&result);
    if (any_id != NULL) {
        note_id(*any_id);
    }

    return result;
}

js_result_t js_runner_t::call(js_id_t id,
                           const std::vector<boost::shared_ptr<scoped_cJSON_t> > &args,
                           const req_config_t &config) {
    guarantee(job_data.has());

    object_buffer_t<js_timeout_t::sentry_t> sentry;
    sentry.create(&job_data->js_timeout, config.timeout_ms);

    try {
        return job_data->js_job.call(id, args);
    } catch (...) {
        // Sentry must be destroyed before the js_timeout
        sentry.reset();
        job_data.reset();
        throw;
    }
}

void js_runner_t::note_id(js_id_t id) {
    guarantee(job_data.has());
    if (id != INVALID_ID) {
        std::pair<std::set<js_id_t>::iterator, bool> res = job_data->used_ids.insert(id);
        guarantee(res.second, "js_runner_t received a duplicate js id");
    }
}
